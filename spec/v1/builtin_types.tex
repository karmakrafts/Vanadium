%! Author = Alexander Hinze
%! Date = 08.11.22

Builtin types are types which can not be expressed as a UDT and which
are provided by the language (and the compiler) itself.
The below table illustrates all types supported by the Ferrous programming language.

\begin{center}
    \begin{tabular}{ |c|c|c|c| }
        \hline
        \textbf{Name} & \textbf{Class} & \textbf{Size (Bytes)} & \textbf{Range}\\
        \hlineB{2.5}
        i8 & \color{type_class_sint} Signed Integer \normalcolor & 1 & -127 to 127\\
        i16 & \color{type_class_sint} " \normalcolor & 2 & -32768 to 32767\\
        i32 & \color{type_class_sint} " \normalcolor & 4 & -2147483648 to 2147483647\\
        i64 & \color{type_class_sint} " \normalcolor & 8 & -9223372036854775808 to 9223372036854775807\\
        \hline
        u8 & \color{type_class_uint} Unsigned Integer \normalcolor & 1 & 0 to 255\\
        u16 & \color{type_class_uint} " \normalcolor & 2 & 0 to 65535\\
        u32 & \color{type_class_uint} " \normalcolor & 4 & 0 to 4294967295\\
        u64 & \color{type_class_uint} " \normalcolor & 8 & 0 to 18446744073709551615\\
        \hline
        f32 & \color{type_class_ieee} IEEE754 \normalcolor & 4 & -3.4E+38 to +3.4E+38\\
        f64 & \color{type_class_ieee} " \normalcolor & 8 & -1.7E+308 to +1.7E+308\\
        \hline
        isize & \color{type_class_size} Native Size \normalcolor & 4 on 32-bit, 8 on 64-bit & Same as i32 on 32-bit, i64 on 64-bit\\
        usize & \color{type_class_size} " \normalcolor & 4 on 32-bit, 8 on 64-bit & Same as u32 on 32-bit, u64 on 64-bit\\
        \hline
        void & \color{type_class_misc} Miscellaneous \normalcolor & 0 & Size-less\\
        bool & \color{type_class_misc} " \normalcolor & 1 & 0 if \textbf{false}, 1 if \textbf{true}\\
        char & \color{type_class_misc} " \normalcolor & 4 & U+010000 to U+10FFFF\\
        \hline
    \end{tabular}
\end{center}

\color{type_class_sint}
\subsection{Signed Integer Types} \label{subsec:signed-integer-types}
\color{secondary_fg}
A signed integer of n bits width comprises 1 sign bit and n-1 data bits.

\color{type_class_uint}
\subsection{Unsigned Integer Types} \label{subsec:unsigned-integer-types}
\color{secondary_fg}
An unsigned integer of n bits width comprises n data bits, without any sign bit.\\
This extra available data bit is the reason why you get double the range of a
signed integer.

\color{type_class_ieee}
\subsection{IEEE754 Types} \label{subsec:ieee754-types}
\color{secondary_fg}
IEEE754 is the standardized way for computers to store binary floating point numbers.\\
It is based on the simple principle of exponentiation.

\begin{center}
    Bit 0
    \fcolorbox{secondary_fg}{primary_bg}{
        \begin{tabular}{c@{\hspace{-0.28cm}}c@{\hspace{-0.25cm}}c}
            0 & 1 to 7 & 8 to 31\\
            {
                \fcolorbox{secondary_fg}{ieee_sign_color}{S}
            } & {
                \fcolorbox{secondary_fg}{ieee_exponent_color}{EEEEEEEE}
            } & {
                \fcolorbox{secondary_fg}{ieee_mantissa_color}{MMMMMMMMMMMMMMMMMMMMMMM}
            }
        \end{tabular}
    }
    Bit 31
\end{center}

\noindent
Where each letter in the above figure represents a single bit of the value in memory.\\
The actual value of a IEEE754 floating point value can be calculated by applying the
following formula to the components of the value:

\begin{center}
    \fontsize{18}{0} \selectfont
    \begin{equation*}
        x=s \times m \times b^e
    \end{equation*}
    \normalfont \selectfont
\end{center}

\noindent
Where \textbf{b} is the base of the representation which in the case of
a normalized IEEE754 floating point value is always 2, \textbf{s} is the
sign bit, \textbf{m} is the mantissa value and \textbf{e} is the exponent.

\color{type_class_size}
\subsection{Size Types} \label{subsec:size-types}
\color{secondary_fg}
A native size type is a type of signed or unsigned integer, which has a
varying size in memory based on the target hardware.\\
This is useful for expressing indices and data sizes.

\subsubsection{isize} \label{subsubsec:isize}
A signed version of a native size type, which on 32-bit hardware will be
4 bytes in memory while on 64-bit hardware it will be 8 bytes in memory.\\
This means the value range of this type changes as follows based on the hardware:\\

\begin{center}
    \begin{tabular}{ |c|c|c| }
        \hline
        \textbf{Main ALU Width (Bits)} & \textbf{Memory Size (Bytes)} & \textbf{Range}\\
        \hlineB{2.5}
        32 & 4 & -2147483648 to 2147483647\\
        64 & 8 & -9223372036854775808 to 9223372036854775807\\
        \hline
    \end{tabular}
\end{center}

\subsubsection{usize} \label{subsubsec:usize}
An unsigned version of a native size type, which on 32-bit hardware will be
4 bytes in memory while on 64-bit hardware it will be 8 bytes in memory.
This means the value range of this type changes as follows based on the hardware:\\

\begin{center}
    \begin{tabular}{ |c|c|c| }
        \hline
        \textbf{Main ALU Width (Bits)} & \textbf{Memory Size (Bytes)} & \textbf{Range}\\
        \hlineB{2.5}
        32 & 4 & 0 to 4294967295\\
        64 & 8 & 0 to 18446744073709551615\\
        \hline
    \end{tabular}
\end{center}

\color{type_class_misc}
\subsection{Miscellaneous Types} \label{subsec:miscellaneous-types}
\color{secondary_fg}

\subsubsection{void} \label{subsubsec:void}
A size-less type for denoting a function without a result, normally referred
to as a subroutine.\\
This may also be used as a return-type of a lambda expression.

\subsubsection{bool} \label{subsubsec:bool}
A bool is nothing more than an unsigned 8-bit integer.\\
Its value is restricted to either 0 if the bool is false, or 1 if the bool is true.\\
A bool with a value other than 0 or 1 invokes undefined behaviour.

\subsubsection{char} \label{subsubsec:char}
A char is a 32-bit unsigned integer, which can store any type of UTF-8 character.\\
This means that all runtime strings in Ferrous are by default UTF-8 encoded.